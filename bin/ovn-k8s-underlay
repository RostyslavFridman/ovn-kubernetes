#! /usr/bin/python
# Copyright (C) 2016 Nicira, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import distutils.spawn
import json
import netaddr
import os
import shlex
import sys

import ovn_k8s.common.util as util
from ovn_k8s.common.util import ovs_vsctl
from ovn_k8s.common.util import ovn_nbctl
from ovn_k8s.common import variables

CNI_CONF_PATH = "/etc/cni/net.d"
CNI_LINK_PATH = "/opt/cni/bin/"
CNI_PLUGIN = "ovn-k8s-cni-overlay"


def fetch_ovn_nb():
    OVN_NB = ovs_vsctl("--if-exists", "get", "Open_vSwitch", ".",
                       "external_ids:ovn-nb").strip('"')
    if not OVN_NB:
        raise Exception("OVN central database's ip address not set")

    variables.OVN_NB = OVN_NB


def _create_logical_switch(node_name, vlan_id, local_subnet, router_ip_mask):
    ip = netaddr.IPNetwork(router_ip_mask)
    router_ip_mask = str(ip)

    switch_name = "vlan%s-%s" % (vlan_id, node_name)
    # Create a logical switch and set its subnet.
    ovn_nbctl("--", "--may-exist", "ls-add", switch_name,
              "--", "set", "logical_switch", switch_name,
              "other-config:subnet=" + local_subnet,
              "external-ids:gateway_ip=" + router_ip_mask)

    return switch_name


def _connect_switch_to_router(switch_name, node_name, vlan_id, router_mac, router_ip_mask):
    # Connect the switch to the router.
    ovn_nbctl("--", "--may-exist", "lsp-add", switch_name,
              "stor-" + vlan_id + "-" + node_name,
              "--", "set", "logical_switch_port",
              "stor-" + vlan_id + "-" + node_name, "type=router",
              "options:router-port=rtos-" + vlan_id + "-" + node_name,
              "addresses=" + "\"" + router_mac + " " + router_ip_mask + "\"")


def _create_vlan_access_port(vlan_id, switch_name, mgmtif_name):
        # Create vlan access port
        interface_name = "vlan%s-if" % (vlan_id)
        ovn_nbctl("--", "--may-exist", "lsp-add", switch_name,
                  interface_name, '', vlan_id,
                  "--", "lsp-set-addresses", interface_name, "unknown",
                  "--", "lsp-set-type", interface_name, "localnet")

        # Connect vlan access port to external network
        ovn_nbctl("--", "lsp-set-options", interface_name,
                  "network_name=physical_net")

        # Create a OVS internal interface
        ovs_vsctl("--", "--may-exist", "add-port", "br-int",
                  mgmtif_name, "--", "set", "interface",
                  mgmtif_name, "type=internal",
                  "mtu_request=1400",
                  "external-ids:iface-id=" + mgmtif_name)

        mac_address = ovs_vsctl("--if-exists", "get", "interface",
                                mgmtif_name, "mac_in_use").strip('"')
        if not mac_address:
            raise Exception("failed to get mac address of ovn-k8s-master")

        # Create the OVN logical port
        ovn_nbctl("--", "--may-exist", "lsp-add", switch_name,
                  mgmtif_name, "--", "lsp-set-addresses",
                  mgmtif_name, mac_address)


def _create_logical_router_port(node_name, vlan_id, mgmt_ip):
    router_name = "vlan%s-%s" % (vlan_id, node_name)
    # Create router port
    router_mac = ovn_nbctl("--if-exist", "get", "logical_router_port",
                           "rtos-" + vlan_id + "-" + node_name,
                           "mac").strip('"')
    if not router_mac:
        router_mac = util.generate_mac()
        ovn_nbctl("--", "--may-exist", "lrp-add", router_name,
                  "rtos-" + vlan_id + "-" + node_name,
                  router_mac, mgmt_ip)

    return router_mac


def _create_balancer(switch_name):
    # Add the load_balancer to the switch.
    k8s_cluster_lb_tcp = ovn_nbctl("--data=bare", "--no-heading",
                                   "--columns=_uuid", "find", "load_balancer",
                                   "external_ids:k8s-cluster-lb-tcp=yes")
    if k8s_cluster_lb_tcp:
        ovn_nbctl("set", "logical_switch", switch_name,
                  "load_balancer=" + k8s_cluster_lb_tcp)

    k8s_cluster_lb_udp = ovn_nbctl("--data=bare", "--no-heading",
                                   "--columns=_uuid", "find", "load_balancer",
                                   "external_ids:k8s-cluster-lb-udp=yes")
    if k8s_cluster_lb_udp:
        ovn_nbctl("add", "logical_switch", switch_name,
                  "load_balancer", k8s_cluster_lb_udp)


def create_management_port(node_name, vlan_id, local_subnet, mgmt_ip):

    router_mac = _create_logical_router_port(node_name,
                                             vlan_id,
                                             mgmt_ip)

    switch_name = _create_logical_switch(node_name, vlan_id, local_subnet,
                                         mgmt_ip)

    _connect_switch_to_router(switch_name, node_name, vlan_id, router_mac,
                              mgmt_ip)

    mgmtif_name = "vlan%s-mgmt" % (vlan_id)
    _create_vlan_access_port(vlan_id, switch_name, mgmtif_name)

    # Shutdown the interface.
    command = "ip link set %s down" % (mgmtif_name)
    util.call_popen(shlex.split(command))

    # The interface may already exist, in which case delete the routes and IP.
    command = "ip addr flush dev %s" % (mgmtif_name)
    util.call_popen(shlex.split(command))

    _create_balancer(switch_name)


def create_public_interface(node_name, vlan_id, local_subnet, default_gw,
                            public_if_ip):

    switch_name = _create_logical_switch(node_name, vlan_id, local_subnet,
                                         default_gw)

    mgmtif_name = "public-if"
    _create_vlan_access_port(vlan_id, switch_name, mgmtif_name)
    command = "ifconfig %s %s" % (mgmtif_name, public_if_ip)
    util.call_popen(shlex.split(command))


def master_init(args):
    fetch_ovn_nb()

    if not args.node_name or not args.vlan_ip_subnet \
       or not args.vlan_id:
        raise Exception("Arguments should be non-null")

    router_name = "vlan%s-%s" % (args.vlan_id, args.node_name)

    # Create a logical router
    ovn_nbctl("--", "--may-exist", "lr-add", router_name)

    # Create 2 load-balancers for east-west traffic.  One handles UDP
    # and another handles TCP.
    k8s_cluster_lb_tcp = ovn_nbctl("--data=bare", "--no-heading",
                                   "--columns=_uuid", "find", "load_balancer",
                                   "external_ids:k8s-cluster-lb-tcp=yes")
    if not k8s_cluster_lb_tcp:
        ovn_nbctl("--", "create", "load_balancer",
                  "external_ids:k8s-cluster-lb-tcp=yes")

    k8s_cluster_lb_udp = ovn_nbctl("--data=bare", "--no-heading",
                                   "--columns=_uuid", "find", "load_balancer",
                                   "external_ids:k8s-cluster-lb-udp=yes")
    if not k8s_cluster_lb_udp:
        ovn_nbctl("--", "create", "load_balancer",
                  "external_ids:k8s-cluster-lb-udp=yes", "protocol=udp")

    # Create 2 load-balancers for north-south traffic.  One handles UDP
    # and another handles TCP.
    k8s_ns_lb_tcp = ovn_nbctl("--data=bare", "--no-heading",
                              "--columns=_uuid", "find", "load_balancer",
                              "external_ids:k8s-ns-lb-tcp=yes")
    if not k8s_ns_lb_tcp:
        ovn_nbctl("--", "create", "load_balancer",
                  "external_ids:k8s-ns-lb-tcp=yes")

    k8s_ns_lb_udp = ovn_nbctl("--data=bare", "--no-heading",
                              "--columns=_uuid", "find", "load_balancer",
                              "external_ids:k8s-ns-lb-udp=yes")
    if not k8s_ns_lb_udp:
        ovn_nbctl("--", "create", "load_balancer",
                  "external_ids:k8s-ns-lb-udp=yes", "protocol=udp")

    create_management_port(args.node_name, args.vlan_id,
                           args.vlan_ip_subnet, args.mgmt_ip)

    if args.public_if_ip:
        create_public_interface(args.node_name, args.vlan_id, args.vlan_ip_subnet,
                                args.default_gw, args.public_if_ip)
    # Add a static route in GR with physical gateway as the default next hop.
    if args.default_gw:
        ovn_nbctl("--may-exist", "lr-route-add", router_name,
                  "0.0.0.0/0", str(args.default_gw))


def minion_init(args):
    fetch_ovn_nb()

    if not args.node_name or not args.vlan_ip_subnet \
       or not args.vlan_id:
        raise Exception("Arguments should be non-null")

    cni_plugin_path = distutils.spawn.find_executable(CNI_PLUGIN)
    if not cni_plugin_path:
        raise Exception("No CNI plugin %s found" % CNI_PLUGIN)

    if not os.path.exists(CNI_LINK_PATH):
        os.makedirs(CNI_LINK_PATH)

    cni_file = "%s/ovn_cni" % CNI_LINK_PATH
    if not os.path.isfile(cni_file):
        command = "ln -s %s %s" % (cni_plugin_path, cni_file)
        util.call_popen(shlex.split(command))

    # Create the CNI config
    if not os.path.exists(CNI_CONF_PATH):
        os.makedirs(CNI_CONF_PATH)

    CNI_FILE = "%s/10-net.conf" % CNI_CONF_PATH

    if not os.path.isfile(CNI_FILE):
        data = {
            "name": "net",
            "type": "ovn_cni",
            "bridge": "br-int",
            "isGateway": "true",
            "ipMasq": "false",
            "ipam": {
                    "type": "host-local",
                    "subnet": args.vlan_ip_subnet
            }
        }
        with open(CNI_FILE, 'w') as outfile:
            json.dump(data, outfile)

    create_management_port(args.node_name, args.vlan_id,
                           args.vlan_ip_subnet, args.mgmt_ip)


def gateway_init(args):
    if not args.physical_interface:
        raise Exception("Arguments should be non-null")

    ovs_vsctl("--", "--may-exist", "add-br", "br-ext")
    ovs_vsctl("--", "set", "open", ".",
              "external-ids:ovn-bridge-mappings=physical_net:br-ext")
    ovs_vsctl("--", "--may-exist", "add-port", "br-ext",
              args.physical_interface)
    ovs_vsctl("--", "set", "interface", args.physical_interface,
              "lldp:enable=true")


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title='Subcommands',
                                       dest='command_name')

    # Parser for sub-command 'master-init'.
    parser_master_init = subparsers.add_parser(
        'master-init',
        help="Initialize k8s master node")
    parser_master_init.add_argument('--vlan-ip-subnet',
                                    required=True,
                                    help="IP subnet for the vlan.")
    parser_master_init.add_argument('--node-name',
                                    required=True,
                                    help="A unique node name.")
    parser_master_init.add_argument('--vlan-id',
                                    required=True,
                                    help="VLAN id.")
    parser_master_init.add_argument('--mgmt-ip',
                                    help="Management IP address.")
    parser_master_init.add_argument('--default-gw',
                                    help="Default gateway with subnet.")
    parser_master_init.add_argument('--public-if-ip',
                                    help="Set public interface with IP/CIDR")
    parser_master_init.set_defaults(func=master_init)

    # Parser for sub-command 'minion-init'.
    parser_minion_init = subparsers.add_parser(
        'minion-init',
        help="Initialize k8s minion node")
    parser_minion_init.add_argument('--vlan-ip-subnet',
                                    required=True,
                                    help="IP subnet for the vlan.")
    parser_minion_init.add_argument('--node-name',
                                    required=True,
                                    help="A unique node name.")
    parser_minion_init.add_argument('--vlan-id',
                                    required=True,
                                    help="VLAN id.")
    parser_minion_init.add_argument('--mgmt-ip',
                                    help="Management IP address.")
    parser_minion_init.add_argument('--default-gw',
                                    help="Default gateway with subnet.")
    parser_minion_init.set_defaults(func=minion_init)

    # Parser for sub-command 'gateway-init'.
    parser_gateway_init = subparsers.add_parser(
        'gateway-init',
        help="Initialize k8s gateway node")
    parser_gateway_init.add_argument('--physical-interface', required=True,
                                     help="The physical interface via which "
                                     "external connectivity is provided.")
    parser_gateway_init.set_defaults(func=gateway_init)
    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        sys.stderr.write("Failed operation.\n(%s)" % str(e))
        sys.exit(1)
